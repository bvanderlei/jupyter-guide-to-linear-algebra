
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solving Systems using Elimination &#8212; Jupyter Guide to Linear Algebra</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/sphinx-book-theme.2d2078699c18a0efb88233928e1cf6ed.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.be0a4a0c39cd630af62a2fcf693f3f06.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LU Factorization" href="LU_Factorization.html" />
    <link rel="prev" title="Matrix Algebra" href="Matrix_Algebra.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Jupyter Guide to Linear Algebra</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Welcome to the Jupyter Guide to Linear Algebra
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="Jupyter_Introduction.html">
   Introduction to Jupyter
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="Linear_Systems.html">
   Linear Systems
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="Gaussian_Elimination.html">
     Gaussian Elimination
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="Matrix_Algebra.html">
     Matrix Algebra
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Solving Systems using Elimination
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="LU_Factorization.html">
     LU Factorization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="Inverse_Matrices.html">
     Inverse Matrices
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="Applications.html">
     Applications
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Vector_Spaces.html">
   Vector Spaces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Linear_Transformations.html">
   Linear Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Inner_Products.html">
   Inner Products
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Eigenvalues.html">
   Eigenvalues
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/Solving_Systems.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/bvanderlei/jupyter-guide-to-linear-algebra/main?urlpath=tree/Solving_Systems.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#back-substitution-routine">
   Back Substitution routine
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#row-reduction-routine">
   Row Reduction routine
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#system-solve-routine">
   System Solve routine
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exercise">
     Exercise
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   Exercises
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="solving-systems-using-elimination">
<h1>Solving Systems using Elimination<a class="headerlink" href="#solving-systems-using-elimination" title="Permalink to this headline">¶</a></h1>
<p>In this section we discuss the code needed to solve the linear system <span class="math notranslate nohighlight">\(AX=B\)</span> using elimination.  We will restrict objective to the case where <span class="math notranslate nohighlight">\(A\)</span> is a square <span class="math notranslate nohighlight">\(n\times n\)</span> matrix, and the the system has exactly one solution. The more general case requires more knowledge of the underlying theory and will be addressed in a later chapter.</p>
<p>When writing code to perform a complex problem, it is often a good idea to first break up the task, and write code to carry out smaller pieces.  Once we have code to reliably perform the small tasks, we can assemble the pieces to solve the larger problem.  In our case we will break down the solution method into two parts.</p>
<ol class="simple">
<li><p>Carry out elimination on the associated augmented matrix.</p></li>
<li><p>Perform back substitution on the triangular system that elimination produces.</p></li>
</ol>
<p>It is also beneficial to consider how we might write the code now so that it will it can reuse it for other tasks later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">laguide</span> <span class="k">as</span> <span class="nn">lag</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="back-substitution-routine">
<h2>Back Substitution routine<a class="headerlink" href="#back-substitution-routine" title="Permalink to this headline">¶</a></h2>
<p>We will start with the back substitution step, since that is the easier part.  If the elimination step is successful, we will have an upper triangular system <span class="math notranslate nohighlight">\(UX=B\)</span> that has the following form.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
\left[ \begin{array}{rrrr} * &amp; * &amp; * &amp; * \\ 0 &amp; * &amp; * &amp; * \\ 0 &amp; 0 &amp; * &amp; * \\ 0 &amp; 0 &amp; 0 &amp; * \end{array}\right]
\left[ \begin{array}{r}  x_1 \\  x_2  \\ x_3 \\ x_4  \end{array}\right]=
\left[ \begin{array}{r}  * \\  *  \\ * \\ *  \end{array}\right]
\end{equation}
\end{split}\]</div>
<p>We will put the code in a function so that that it is easy to reuse later.  For this function, let’s suppose that we are given the upper triangular matrix <span class="math notranslate nohighlight">\(U\)</span> and the known vector <span class="math notranslate nohighlight">\(B\)</span> and we want to find the vector <span class="math notranslate nohighlight">\(X\)</span> so that <span class="math notranslate nohighlight">\(UX=B\)</span>.  Note we could make other assumptions, such as the matrix <span class="math notranslate nohighlight">\(U\)</span> having diagonal entries equal to 1, but if we make fewer assumptions, the code will be more useful later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">BackSubstitution</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#     U is a NumPy array that represents an upper triangular square mxm matrix.  </span>
<span class="c1">#     B is a NumPy array that represents an mx1 vector     </span>
<span class="c1">#     BackSubstitution will return an mx1 vector that is the solution of the</span>
<span class="c1">#     system UX=B.</span>
<span class="c1"># =============================================================================</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># m is number of rows and columns in U</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># Calculate entries of X backward from m-1 to 0</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X</span>
</pre></div>
</div>
</div>
</div>
<p>Before moving on, let’s test this function.  We can build a matrix with the proper triangular form, <em>choose a solution</em>, and then construct a system <span class="math notranslate nohighlight">\(UX=B\)</span> so that we know the solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make up an upper triangular matrix.  Could we make a random upper triangular matrix here?  What could go wrong?</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">]])</span>  
<span class="c1"># We will choose the solution X_true.  We can put in any numbers we like here. </span>
<span class="n">X_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">6</span><span class="p">]])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">U</span><span class="nd">@X_true</span>
<span class="c1"># Call the function.  It should produce the same array as X_true if it works correctly.</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">BackSubstitution</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[2.]
 [4.]
 [6.]]
</pre></div>
</div>
</div>
</div>
<p>Before discussing the elimination step, we should make a note that this <span class="math notranslate nohighlight">\(\texttt{BackSubstitution}\)</span> function <em>will fail</em> if any of the diagonal entries of <span class="math notranslate nohighlight">\(U\)</span> are zero.  We should keep this in mind when using this code in the future.</p>
</div>
<div class="section" id="row-reduction-routine">
<h2>Row Reduction routine<a class="headerlink" href="#row-reduction-routine" title="Permalink to this headline">¶</a></h2>
<p>Elimination is the larger and more complex part of the solution method.  It is also a common task that will arise in future sections, so we will want some code that we can reuse at a later point.  We want a function that will carry out all the steps of elimination, and just return the end result.  It is not necessary to see all the inividual row operations that took place in order solve the problem.  Ideally, we would like the function to carry out the elimination on arrays of any size or shape, and also be able to <em>make the decision</em> to perform row swaps when necessary.</p>
<p>To clarify the goal, the function should accept an arbitrary array and produce an array that has the following properties.</p>
<ul class="simple">
<li><p>The first nonzero entry in each row is a 1.  These entries are the pivots.</p></li>
<li><p>Each pivot is located to the right of the pivots in all rows above it.</p></li>
<li><p>The entries below each pivot are 0.</p></li>
<li><p>Rows that are all zeros are located below other rows.</p></li>
</ul>
<p>Such a matrix is said to be in a <strong>row echelon form</strong>.  Here are three examples of matrices in the form that we seek.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
\left[ \begin{array}{cccc} 1 &amp; * &amp; * &amp; * \\ 0 &amp; 1 &amp; * &amp; * \\ 0 &amp; 0 &amp; 1 &amp; * \end{array}\right]
\end{equation}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
\left[ \begin{array}{ccc} 1 &amp; * &amp; *  \\ 0 &amp; 0 &amp; 1  \\ 0 &amp; 0 &amp; 0 \end{array}\right]
\end{equation}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
\left[ \begin{array}{cccccc} 1 &amp; * &amp; * &amp; * &amp; * &amp; * \\ 0 &amp; 0 &amp; 1 &amp; * &amp; * &amp; * \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; * &amp; * \end{array}\right]
\end{equation}
\end{split}\]</div>
<p>It is important to notice that each row can contain at most one pivot and each column can contain at most one pivot.</p>
<p>Before presenting the code to find the row echelon form of a matrix, we first discuss the matrices we will be working with in the case that we are solving the a <span class="math notranslate nohighlight">\(AX=B\)</span> that has a unique solution.  We recall from the <a class="reference internal" href="Gaussian_Elimination.html"><span class="doc std std-doc">Gaussian Elimination</span></a> that the same row operations needed to bring <span class="math notranslate nohighlight">\(A\)</span> to row echelon form must also be applied to <span class="math notranslate nohighlight">\(B\)</span>.  In practice we can join <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> together to form what we call an <strong>augmented matrix</strong>, and carry out the row operations on this single matrix.  Here is an example of the augmented matrix associated with the system <span class="math notranslate nohighlight">\(AX=B\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
AX = B \hspace{1cm} \left[ \begin{array}{rrr} 3 &amp; -1 \\ 5 &amp; 2 \end{array}\right]
\left[ \begin{array}{r} x_1 \\ x_2 \end{array}\right]=
\left[ \begin{array}{r} 0\\ 7  \end{array}\right] \hspace{1cm} \to \hspace{1cm}
\left[ \begin{array}{rrr} 3 &amp; -1 &amp; 0 \\ 5 &amp; 2 &amp; 7 \end{array}\right]
\hspace{1cm} \mbox{augmented matrix}
\end{equation}
\end{split}\]</div>
<p>In our current objective, <span class="math notranslate nohighlight">\(A\)</span> is <span class="math notranslate nohighlight">\(n\times n\)</span>, which means that the augmented matrix we need to process will be <span class="math notranslate nohighlight">\(n\times(n+1)\)</span>.  We are also assuming at this point that the system <span class="math notranslate nohighlight">\(AX=B\)</span> has a unique solution.  If this is true the augmented matrix will have a pivot in each of the first <span class="math notranslate nohighlight">\(n\)</span> columns, with the pivot positions lying along the diagonal line of entries starting at the top left entry.  If the row echelon form of the augmented matrix has a zero in any of these positions, our solution process breaks down as shown in the <a class="reference internal" href="Gaussian_Elimination.html"><span class="doc std std-doc">Gaussian Elimination</span></a> examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">RowReduction</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># A is a NumPy array that represents an augmented matrix of dimension n x (n+1)</span>
<span class="c1"># associated with a linear system.  RowReduction returns B, a NumPy array that</span>
<span class="c1"># represents the row echelon form of A.  RowReduction may not return correct</span>
<span class="c1"># results if the the matrix A does not have a pivot in each column.</span>
<span class="c1"># =============================================================================</span>
   
    <span class="n">m</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># A has m rows </span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># It is assumed that A has m+1 columns</span>
    
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="c1"># For each step of elimination, we find a suitable pivot, move it into</span>
    <span class="c1"># position and create zeros for all entries below.</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="c1"># Set pivot as (k,k) entry</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="n">pivot_row</span> <span class="o">=</span> <span class="n">k</span>
        
        <span class="c1"># Find a suitable pivot if the (k,k) entry is zero</span>
        <span class="k">while</span><span class="p">(</span><span class="n">pivot</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pivot_row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">pivot_row</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">pivot_row</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            
        <span class="c1"># Swap row if needed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pivot_row</span> <span class="o">!=</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">RowSwap</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">pivot_row</span><span class="p">)</span>
            
        <span class="c1"># If pivot is nonzero, carry on with elimination in column k</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pivot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">RowScale</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>    
                <span class="n">B</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">RowAdd</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pivot could not be found in column&quot;</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span>
</pre></div>
</div>
</div>
</div>
<p>Note that in this routine we make use of the row operations written earlier.  Since those functions are note written in <em>this notebook</em>, we need to import them from the <span class="math notranslate nohighlight">\(\texttt{laguide}\)</span> module.</p>
<p>Let’s test the routine on a random array.  Run the code on several random matrices of different sizes and shapes.  Does it always work?  Do you notice any unusual results?  Does it depend on the size or shape?  Does it depend on the range of numbers used?</p>
<p>If you run this test enough times, you are likely to come across an example where the results look a little different.  Here is one such case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">NumericalReductionExample</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">],[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">RowReduction</span><span class="p">(</span><span class="n">NumericalReductionExample</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1.00000000e+00 -8.57142857e-01  8.57142857e-01 -1.14285714e+00]
 [-0.00000000e+00  1.00000000e+00  5.84905660e-01  1.88679245e-01]
 [-0.00000000e+00 -0.00000000e+00  1.00000000e+00  7.08463950e-01]
 [-0.00000000e+00 -0.00000000e+00  1.30206303e-17  1.00000000e+00]]
</pre></div>
</div>
</div>
</div>
<p>There are two things that we observe in this example.  First and most obvious is that the entries are all displayed in scientific notation.  The more disturbing observation is that the result is not exactly what we wanted.  The elimination process is supposed to produce zeros for all the entries below the main diagonal, but in this case there is one entry that is not <span class="math notranslate nohighlight">\(\texttt{0.000}\)</span>.  Instead it is an extremely small number, close to <span class="math notranslate nohighlight">\(10^{-17}\)</span>.  At this point we might question the code and start looking for errors, but the problem here does not lie with the code.  The issue here is something deeper, and involves the precision limitations of the computer.  When the computer carries out the operations of arithmetic it does not always work with exact numbers.  In most cases the results get rounded off to a number that the machine can represent.  This limitation is known as <strong>roundoff error</strong> and it is the reason we do not get exactly zero for all of the entries below the diagonal.</p>
<p>Roundoff error can present a significant challenge if we work with large arrays, and the errors are allowed to accumulate and compound.  There are strategies that can be employed to mitigate this error, and we will revisit this dicussion in a later section.  For now we will carry on with elimination with the awareness that the results we get are not always <em>exactly correct</em>.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Try out the code on two different arrays that require the use of <span class="math notranslate nohighlight">\(\texttt{RowSwap}\)</span>.</p></li>
<li><p>Is it possible to test random arrays that require the use of <span class="math notranslate nohighlight">\(\texttt{RowSwap}\)</span>?</p></li>
</ul>
</div>
<div class="section" id="system-solve-routine">
<h2>System Solve routine<a class="headerlink" href="#system-solve-routine" title="Permalink to this headline">¶</a></h2>
<p>Now we can combine the <span class="math notranslate nohighlight">\(\texttt{RowReduction}\)</span> and the <span class="math notranslate nohighlight">\(\texttt{BackSubstitution}\)</span> routines together to carry out the solution algorithm for the system <span class="math notranslate nohighlight">\(AX=B\)</span>.  A simple possibility is that the user of the function will supply <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, and the function will return the solution <span class="math notranslate nohighlight">\(X\)</span>.  Let’s list the steps that need to be completed.</p>
<ol class="simple">
<li><p>Build the associated augmented matrix.</p></li>
<li><p>Apply <span class="math notranslate nohighlight">\(\texttt{RowReduction}\)</span>.</p></li>
<li><p>Split the matrix.</p></li>
<li><p>Apply <span class="math notranslate nohighlight">\(\texttt{BackSubstitution}\)</span> and return the result.</p></li>
</ol>
<p>Note that there are other ways we could build our routine.  We could require the user to supply the augmented matrix for example, but then that means the user (us) has to do step 1 everytime they use this routine.  It is better to let the function handle that step.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SolveSystem</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="c1"># =============================================================================</span>
    <span class="c1"># A is a NumPy array that represents a matrix of dimension n x n.</span>
    <span class="c1"># B is a NumPy array that represents a matrix of dimension n x 1.</span>
    <span class="c1"># SolveSystem returns a NumPy array of dimension n x 1 such that AX = B.</span>
    <span class="c1"># If the system AX = B does not have a unique solution, SolveSystem may not</span>
    <span class="c1"># generate correct results.</span>
    <span class="c1"># =============================================================================</span>

    <span class="c1"># Check shape of A</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SolveSystem accepts only square arrays.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># n is number of rows and columns in A</span>

    <span class="c1"># 1. Join A and B to make the augmented matrix</span>
    <span class="n">A_augmented</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="c1"># 2. Carry out elimination    </span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">RowReduction</span><span class="p">(</span><span class="n">A_augmented</span><span class="p">)</span>

    <span class="c1"># 3. Split R back to nxn piece and nx1 piece</span>
    <span class="n">B_reduced</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A_reduced</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="c1"># 4. Do back substitution</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">BackSubstitution</span><span class="p">(</span><span class="n">A_reduced</span><span class="p">,</span><span class="n">B_reduced</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s test the routine by building a matrix, choosing a solution, and constructing a system <span class="math notranslate nohighlight">\(AX=B\)</span> so that we know the solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
<span class="c1"># We will choose the solution X_true</span>
<span class="n">X_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="c1"># Now make B so that the solution to AX=B is X_true</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="nd">@X_true</span>
<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">SolveSystem</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 6]
 [-1]
 [ 4]]
[[1.]
 [1.]
 [1.]]
</pre></div>
</div>
</div>
</div>
<p>Next, we modify a couple of lines to produce a completely random system with random solution.  We will use <span class="math notranslate nohighlight">\(\texttt{SolveSystem}\)</span> to find the solution and then compute the difference between the result and the actual known solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c1"># We set X_true for a random solution</span>
<span class="n">X_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># Now make B so that the solution to AX=B is X_true</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="nd">@X_true</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">SolveSystem</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="c1"># Print the difference in computed solution and actual solution</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_true</span><span class="o">-</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.00000000e+00]
 [-2.22044605e-16]
 [-2.22044605e-16]
 [ 4.44089210e-16]]
</pre></div>
</div>
</div>
</div>
<div class="section" id="exercise">
<h3>Exercise<a class="headerlink" href="#exercise" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Set up a similar test using <span class="math notranslate nohighlight">\(\text{np.random.rand}\)</span> to get random floats as matrix entries.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># We set X_true for a random solution</span>
<span class="n">X_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Now make B so that the solution to AX=B is X_true</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="nd">@X_true</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">SolveSystem</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="c1"># Print the difference in computed solution and actual solution</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_true</span><span class="o">-</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1.33226763e-15]
 [-1.44328993e-15]
 [ 0.00000000e+00]
 [-1.11022302e-16]]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>Exercises<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Use <span class="math notranslate nohighlight">\(\texttt{np.random.rand(n,n)}\)</span> to generate a coefficient matrix with entries that are random floats.  Create a  linear system with a known solution using this matrix, and test <span class="math notranslate nohighlight">\(\texttt{SolveSystem}\)</span>.</p></li>
<li><p>Modify <span class="math notranslate nohighlight">\(\texttt{RowReduction}\)</span> to compute what is known as the <strong>reduced row echelon form</strong>.  Name the new function <span class="math notranslate nohighlight">\(\texttt{RREF}\)</span>.<br />
A matrix in reduced row echelon form should have the following properties.</p>
<ul>
<li><p>The first nonzero entry in each row is a 1.  These entries are the pivots.</p></li>
<li><p>Each pivot is located to the right of the pivots in all rows above it.</p></li>
<li><p>The entries below <strong>and above</strong> each pivot are 0.</p></li>
<li><p>Rows that are all zeros are located below other rows.
Here is an example of a matrix in reduced row echelon form.</p></li>
</ul>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
\left[ \begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; * \\ 0 &amp; 1 &amp; 0 &amp; * \\ 0 &amp; 0 &amp; 1 &amp; * \end{array}\right]
\end{equation}
\end{split}\]</div>
<p>Note that for the system represented by the augmented matrix in the first example, the solution is given by the entries in the final column.  There is no need for back substitution if the augmented matrix is in reduced row echelon form.</p>
<ul class="simple">
<li><p>Test your <span class="math notranslate nohighlight">\(\texttt{RREF}\)</span> on random <span class="math notranslate nohighlight">\(3\times 4\)</span> matrices, then on random <span class="math notranslate nohighlight">\(n\times (n+1)\)</span> matrices.</p></li>
<li><p>Construct a <span class="math notranslate nohighlight">\(3 \times 3\)</span> system with a known solution and compare the solutions produced using <span class="math notranslate nohighlight">\(\texttt{SolveSystem}\)</span> with those produced using <span class="math notranslate nohighlight">\(\texttt{RREF}\)</span>.</p></li>
<li><p>Experiment to see what might go wrong using <span class="math notranslate nohighlight">\(\texttt{RowReduction}\)</span> on a matrix that is <em>not</em> <span class="math notranslate nohighlight">\(n\times (n+1)\)</span>.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="Matrix_Algebra.html" title="previous page">Matrix Algebra</a>
    <a class='right-next' id="next-link" href="LU_Factorization.html" title="next page">LU Factorization</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Ben Vanderlei<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>